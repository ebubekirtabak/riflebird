# Riflebird AI Coding Rules

## Project Overview
Riflebird is an AI-powered test generation and execution framework that supports unit, integration, E2E, visual, and performance testing across multiple testing frameworks (Vitest, Jest, Playwright, Cypress, Puppeteer, WebdriverIO).

## Core Architecture
- **Design Pattern**: Adapter-based framework abstraction
- **Main Orchestrator**: `packages/core/src/riflebird.ts`
- **Adapters**: Framework-specific implementations in `packages/core/src/adapters/`
- **Configuration**: Zod-based validation in `packages/core/src/config/schema.ts`

## TypeScript Rules

### Type Definitions (CRITICAL)
- **ALWAYS use `type` instead of `interface`** for all type definitions
- **ALWAYS export types** - never define internal-only types
- **NO `any` types allowed** - ESLint enforces this strictly
- **Avoid `as unknown as` casting** - use type guards and validation instead
- **Export named types for public APIs** - no inline type literals for function parameters/returns

```typescript
// ✅ CORRECT
export type UserOptions = { name: string; age: number };
export type CommandHandler = (options: UserOptions) => Promise<void>;

// ❌ INCORRECT - Don't use interface
interface UserOptions { name: string; }

// ❌ INCORRECT - Don't use unexported types
type InternalConfig = { secret: string; };

// ❌ INCORRECT - Don't use any
function handler(options: any) {}

// ❌ INCORRECT - Inline type literals
export function login(opts: { username: string; password: string }): Promise<void> {}
```

### Type Safety
- Use `unknown` for external/untrusted input, narrow with type guards
- Use type predicates for complex validation
- Wrap third-party APIs with well-typed adapters
- Prefix unused parameters with underscore: `_param`

```typescript
// ✅ CORRECT - Type guard validation
export type User = { id: string; name: string };

function isUser(value: unknown): value is User {
  return typeof value === 'object' && value !== null &&
         'id' in value && typeof value.id === 'string' &&
         'name' in value && typeof value.name === 'string';
}

export function parseUser(data: unknown): User {
  if (!isUser(data)) {
    throw new Error('Invalid user data');
  }
  return data;
}
```

## Performance & Complexity Optimization

### Algorithm Complexity
- **Prefer O(1) and O(log n) over O(n)** through caching, memoization, proper data structures
- **AVOID O(n²) and higher** - use Maps, Sets, proper indexing instead of nested loops
- **Document complexity** for non-trivial algorithms: `// O(n log n) - sort + binary search`

### Data Structure Guidelines
```typescript
// ❌ O(n²) - Array.includes inside loop
for (const item of items) {
  if (existingIds.includes(item.id)) { /* ... */ }
}

// ✅ O(n) - Use Set for O(1) lookups
const existingIdsSet = new Set(existingIds);
for (const item of items) {
  if (existingIdsSet.has(item.id)) { /* ... */ }
}
```

### Optimization Strategies
- Use `Map` for key-value lookups (O(1)) instead of `Array.find()` (O(n))
- Use `Set` for membership checks (O(1)) instead of `Array.includes()` (O(n))
- Binary search on sorted arrays (O(log n)) instead of linear search (O(n))
- **Batch operations** - single pass instead of multiple iterations
- **Early termination** - use `Array.some()`, `Array.every()`, break loops early
- **Lazy evaluation** - avoid computing values that may not be needed

```typescript
// ❌ Multiple O(n) passes
const filtered = items.filter(x => x.active);
const mapped = filtered.map(x => x.value);
const sum = mapped.reduce((a, b) => a + b, 0);

// ✅ Single O(n) pass
const sum = items.reduce((acc, x) => 
  x.active ? acc + x.value : acc, 0);
```

### Memory Optimization
- Avoid creating unnecessary intermediate arrays/objects in loops
- Use generators (`function*`) for large data sets
- Stream large files instead of loading entirely into memory
- Clear references to large objects when no longer needed

## Test-Driven Development (TDD)

### Core Principles
- **Red-Green-Refactor cycle**: Write failing test first (red) → implement minimal code (green) → refactor for clarity (refactor)
- **Write tests before implementation** for every behavior or API change
- **One assertion concept per test** - each test asserts one behavior
- **Tests are code** - follow same quality rules as production code
- **Deterministic tests** - mock external I/O, control randomness, use fixed time
- **Test interfaces not implementations** - assert public contract/behavior

### Test Requirements
- Unit tests should run in milliseconds, no external service dependencies
- Use descriptive test names: Given/When/Then or natural-language sentences
- Mock and inject dependencies for easier testing
- Commit tests with code - no merging code without tests
- CI must run full test suite and prevent merges if tests fail

```bash
# Run core package tests
pnpm --filter @riflebird/core test

# Run type-checks
pnpm --filter @riflebird/core run type-check
```

## Code Conventions

### Naming
- **File naming**: kebab-case (`rifle-bird-config.ts`)
- **Test naming**: Configurable via `generation.naming` (kebab-case | camelCase | PascalCase)
- **Imports**: Use TypeScript path aliases from `@riflebird/core`

### Error Handling
```typescript
// ✅ CORRECT - Type-safe error handling
catch (error) {
  const message = error instanceof Error ? error.message : String(error);
  console.error(message);
}

// ❌ INCORRECT - Using any
catch (error: any) {
  console.error(error.message);
}
```

## Build & Development

### Monorepo Structure
- Use `pnpm` (version specified in `packageManager` field)
- Turborepo for task orchestration: `pnpm dev`, `pnpm build`, `pnpm test`
- Packages: `packages/core/` (core library), `packages/cli/` (CLI tool)

### Environment
- API keys from env: `process.env.OPENAI_API_KEY`, `process.env.ANTHROPIC_API_KEY`
- **NEVER hardcode API keys** in config files

## Configuration
- Zod-first validation - all config uses Zod schemas
- Type safety via `z.infer<typeof Schema>`
- Dynamic imports via `pathToFileURL` for config loading

## Adding New Features

### New Adapters
1. Create `packages/core/src/adapters/your-framework.ts`
2. Implement `TestFrameworkAdapter` interface
3. Add framework to `FrameworkSchema` enum in `schema.ts`
4. Add case in `Riflebird.createAdapter()`

### Key Integration Points
- AI Provider: OpenAI SDK initialized in `Riflebird.init()`, temperature defaults to 0.2
- Adapter Selection: Framework chosen at runtime via `config.framework`
- Test Generation: User description → AI test plan → Framework-specific code

## Quality Standards
- ESLint must pass - no warnings or errors
- TypeScript strict mode enabled
- All tests must pass before committing
- Throw descriptive errors with context
- Document non-obvious code with comments
- Export all public types and functions
