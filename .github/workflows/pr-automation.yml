name: PR Automation
on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  pull-requests: write
  contents: read

jobs:
  decorate-title:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const currentTitle = pr.title;

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100
            });

            const fileNames = files.map(f => f.filename);

            let newTitle = currentTitle;
            let icon = '';

            // Check for tests
            const hasTests = fileNames.some(f =>
              f.includes('.test.') ||
              f.includes('.spec.') ||
              f.includes('/tests/') ||
              f.includes('/__tests__/')
            );

            // Check for docs
            const isDocsOnly = fileNames.every(f =>
              f.endsWith('.md') ||
              f.includes('docs/') ||
              f.includes('LICENSE')
            );

            if (hasTests) {
              icon = 'üü¢';
            } else if (isDocsOnly) {
              icon = 'üìù';
            } else {
              icon = 'üü•';
            }

            // Strip existing icons to allows updates (e.g., üü• ‚Üí üü¢)
            const cleanTitle = currentTitle.replace(/^(üü¢|üìù|üü•)\s+/, '');

            if (icon) {
              newTitle = `${icon} ${cleanTitle}`;
            }

            // Update title if changed
            if (newTitle !== currentTitle) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                title: newTitle
              });
              console.log(`Updated title to: ${newTitle}`);
            } else {
              console.log('Title already decorated or no decoration needed.');
            }

  validate-title:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request.title;
            const regex = /^(üü¢ |üìù |üü• )?(feat|fix|docs|refactor|test|chore|perf|style|build|ci|revert)(\([a-z0-9-]+\))?!?: .+$/;

            if (!regex.test(title)) {
              core.setFailed(`
                ‚ùå Invalid PR Title key: "${title}"

                Format should follow Conventional Commits:
                <type>(<scope>): <description>

                Examples:
                - feat(RF-123): add new feature
                - fix: resolve crash
                - docs: update readme

                Allowed types: feat, fix, docs, refactor, test, chore, perf, style, build, ci, revert
                (Icons üü¢, üìù or ÔøΩ at the start are allowed)
              `);
            } else {
              console.log('‚úÖ PR Title is valid.');
            }

  add-jira-link:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited'
    steps:
      - uses: actions/github-script@v7
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const branchName = pr.head.ref;
            const jiraRegex = /([A-Z]+-\d+)/;
            const match = branchName.match(jiraRegex);

            if (!match) {
              console.log('No Jira ticket found in branch name.');
              return;
            }

            const ticketId = match[1];
            const body = pr.body || '';
            const placeholder = '<!-- Link to the Jira ticket (e.g., RF-123) or write "None" -->';

            if (!body.includes(placeholder)) {
               console.log('Placeholder not found, skipping update.');
               return;
            }

            const { JIRA_BASE_URL, JIRA_USER_EMAIL, JIRA_API_TOKEN } = process.env;
            let linkText = ticketId;

            if (JIRA_BASE_URL && JIRA_USER_EMAIL && JIRA_API_TOKEN) {
              try {
                // Fetch ticket details
                const response = await fetch(`${JIRA_BASE_URL}/rest/api/3/issue/${ticketId}`, {
                  headers: {
                    'Authorization': `Basic ${Buffer.from(JIRA_USER_EMAIL + ':' + JIRA_API_TOKEN).toString('base64')}`,
                    'Accept': 'application/json'
                  }
                });

                if (response.ok) {
                  const data = await response.json();
                  const summary = data.fields.summary;
                  const status = data.fields.status.name;
                  const browsingUrl = `${JIRA_BASE_URL}/browse/${ticketId}`;

                  // Format: [RF-123](url): Summary (Status)
                  linkText = `[${ticketId}](${browsingUrl}): ${summary} (Status: ${status})`;
                } else {
                  console.log(`Failed to fetch from Jira: ${response.status} ${response.statusText}`);
                }
              } catch (error) {
                console.error('Error fetching from Jira:', error);
              }
            } else {
               console.log('Missing Jira secrets. Falling back to simple ticket ID.');
            }

            const newBody = body.replace(placeholder, linkText);
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              body: newBody
            });
            console.log(`Updated PR body with: ${linkText}`);
