name: PR Automation
on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  pull-requests: write
  contents: read

jobs:
  decorate-title:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    steps:
      - uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const currentTitle = pr.title;

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100
            });

            const fileNames = files.map(f => f.filename);

            let newTitle = currentTitle;

            // ---------------------------------------------------------
            // Attempt to auto-fix title from branch name if it looks like default
            // Branch format: type/ticket-description (e.g., chore/RF-21-add-stuff)
            // Target format: type(ticket): description
            // ---------------------------------------------------------
            const branchName = pr.head.ref;
            const branchRegex = /^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)\/([A-Z]+-\d+)-(.*)$/;
            const branchMatch = branchName.match(branchRegex);

            if (branchMatch) {
              const type = branchMatch[1];
              const scope = branchMatch[2];
              const rawDesc = branchMatch[3];
              const desc = rawDesc.replace(/-/g, ' '); // replace dashes with spaces

              const conventionalTitle = `${type}(${scope}): ${desc}`;

              // If the current title seems to be just the "humanized" branch name (illegal)
              // or if it fails conventional commits check, we replace it.
              // GitHub defaults: "Chore/rf 21 implement..." (Capitalized, slashes may remain or spaces)

              // Simple heuristic: If title doesn't start with a valid type and colon
              // (Using relaxed regex to match validation logic)
              const conventionalRegex = /^([^a-zA-Z0-9]+\s+)?(feat|fix|docs|refactor|test|chore|perf|style|build|ci|revert)(\([a-zA-Z0-9-]+\))?!?: .+$/;

              if (!conventionalRegex.test(currentTitle)) {
                 console.log(`Detected invalid title: "${currentTitle}". Auto-fixing based on branch "${branchName}".`);
                 newTitle = conventionalTitle;
              }
            }

            let icon = '';

            // Check for tests
            const hasTests = fileNames.some(f =>
              f.includes('.test.') ||
              f.includes('.spec.') ||
              f.includes('/tests/') ||
              f.includes('/__tests__/')
            );

            // Check for docs
            const isDocsOnly = fileNames.every(f =>
              f.endsWith('.md') ||
              f.includes('docs/') ||
              f.includes('LICENSE')
            );

            if (hasTests) {
              icon = 'üü¢';
            } else if (isDocsOnly) {
              icon = 'üìù';
            } else {
              icon = 'üü•';
            }

            // Strip existing icons to allow updates (e.g., üü• ‚Üí üü¢)
            const sourceTitle = newTitle || currentTitle;
            const cleanTitle = sourceTitle.replace(/^(üü¢|üìù|üü•)\s+/, '');

            if (icon) {
              newTitle = `${icon} ${cleanTitle}`;
            }

            // Update title if changed
            if (newTitle !== currentTitle) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                title: newTitle
              });
              console.log(`Updated title to: ${newTitle}`);
            } else {
              console.log('Title already decorated or no decoration needed.');
            }

  validate-title:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v8
        with:
          script: |
            const title = context.payload.pull_request.title;
            // Relaxed Regex:
            // 1. Allows any non-alphanumeric chars at the start (for icons like üü•, üü¢, üìù)
            // 2. Allows UpperCase in scope (e.g., (RF-123))
            const regex = /^([^a-zA-Z0-9]+\s+)?(feat|fix|docs|refactor|test|chore|perf|style|build|ci|revert)(\([a-zA-Z0-9-]+\))?!?: .+$/;

            if (!regex.test(title)) {
              core.setFailed(`
                ‚ùå Invalid PR Title key: "${title}"

                Format should follow Conventional Commits:
                <type>(<scope>): <description>

                Examples:
                - feat(RF-123): add new feature
                - fix: resolve crash
                - docs: update readme

                Allowed types: feat, fix, docs, refactor, test, chore, perf, style, build, ci, revert
                (Icons üü•, üü¢, üìù at the start are allowed)
              `);
            } else {
              console.log('‚úÖ PR Title is valid.');
            }

  add-jira-link:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'synchronize'
    steps:
      - uses: actions/github-script@v8
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const branchName = pr.head.ref;
            const jiraRegex = /([A-Z]+-\d+)/;
            const match = branchName.match(jiraRegex);

            if (!match) {
              console.log('No Jira ticket found in branch name.');
              return;
            }

            const ticketId = match[1];
            const body = pr.body || '';

            // 1. Idempotency Check: Avoid duplicates
            // Check if a link [RF-123] already exists
            const linkRegex = new RegExp(`\\[${ticketId}\\]`);
            if (linkRegex.test(body)) {
               console.log(`Ticket ${ticketId} already linked. Skipping.`);
               return;
            }

            // Check if the ticket ID is already present under the Jira Ticket header (plain text case)
            if (body.includes('## Jira Ticket')) {
               const parts = body.split('## Jira Ticket');
               // Check the content after the header
               if (parts[1] && parts[1].includes(ticketId)) {
                  console.log(`Ticket ${ticketId} already present in Jira section. Skipping.`);
                  return;
               }
            }

            const { JIRA_BASE_URL, JIRA_USER_EMAIL, JIRA_API_TOKEN } = process.env;
            let linkText = ticketId; // Default fallback

            // Try to construct a proper link
            if (JIRA_BASE_URL) {
              const browsingUrl = `${JIRA_BASE_URL}/browse/${ticketId}`;
              // Start with a basic link
              linkText = `[${ticketId}](${browsingUrl})`;

              if (JIRA_USER_EMAIL && JIRA_API_TOKEN) {
                try {
                  // Fetch ticket details for a richer summary
                  const response = await fetch(`${JIRA_BASE_URL}/rest/api/3/issue/${ticketId}`, {
                    headers: {
                      'Authorization': `Basic ${Buffer.from(JIRA_USER_EMAIL + ':' + JIRA_API_TOKEN).toString('base64')}`,
                      'Accept': 'application/json'
                    }
                  });

                  if (response.ok) {
                    const data = await response.json();
                    const summary = data.fields.summary;
                    const status = data.fields.status.name;
                    // Rich format: [RF-123](url): Summary (Status)
                    linkText = `[${ticketId}](${browsingUrl}): ${summary} (Status: ${status})`;
                  } else {
                    console.log(`Failed to fetch from Jira: ${response.status} ${response.statusText}`);
                  }
                } catch (error) {
                  console.error('Error fetching from Jira:', error);
                }
              } else {
                 console.log('Missing Jira credentials, using basic link.');
              }
            } else {
               console.log('Missing JIRA_BASE_URL. Using plain ticket ID text.');
            }

            // 2. Replacement Logic
            const placeholderRegex = /<!--\s*Link to the Jira ticket \(e\.g\., RF-123\) or write "None"\s*-->/i;
            let newBody = body;

            if (placeholderRegex.test(body)) {
               newBody = body.replace(placeholderRegex, linkText);
            } else if (body.includes('## Jira Ticket')) {
               // Append under the existing header
               newBody = body.replace('## Jira Ticket', `## Jira Ticket\n\n${linkText}`);
            } else {
               // Append new section to end
               newBody = `${body}\n\n## Jira Ticket\n\n${linkText}`;
            }

            if (newBody !== body) {
               await github.rest.pulls.update({
                 owner: context.repo.owner,
                 repo: context.repo.repo,
                 pull_number: pr.number,
                 body: newBody
               });
               console.log(`Updated PR body with: ${linkText}`);
            } else {
               console.log('No changes needed for PR body.');
            }
